/* autogenerated by Processing revision 1293 on 2024-05-28 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class persceptron extends PApplet {

//Dataset
Point[]data=new Point[500];
nNetwork ai;
int c;

public void setup(){
  //setting window
  /* size commented out by preprocessor */;
  //init Points 
  for(int i=0;i<data.length;i++){
   data[i]=new Point();
  }
  //init ml
  ai= new nNetwork();
  c=0;
}
public void draw(){
 background(0);
 //diplaying points and teaching NN
 for(Point p:data){
   p.show();
   ai.train(p);
 }
 // ai.train(data[c]);
 //c = (c + 1) % data.length;

 var p1 = new Point(-100,realFunction(-100));
 var p2 = new Point(100,realFunction(100));
 stroke(255);
 line(p1.px,p1.py,p2.px,p2.py);
 
 var p3 = new Point(-100,ai.guessY(-100));
 var p4 = new Point(100,ai.guessY(100));
 stroke(255,255,0);
 line(p3.px,p3.py,p4.px,p4.py);





 for(Point p:data){
 int guess = ai.guess(p);
 int error = p.type-guess;
 if (error==0){
   noStroke();
   fill(0,255,0);
   ellipse(p.px,p.py,7,7);
    }else{
   noStroke();
   fill(255,0,0);
   ellipse(p.px,p.py,7,7);
   }
}
ai.show();
}


public void mousePressed() {
  //training
  int i = 0;
 for(Point p:data){
 // ai.train(p);
  //i++;
 }
 println(i);
}
class Point{
  public float x;
  public float y;
  public float[] cords=new float[3];
 
  public int type;
  public float px;
  public float py;
  Point(float _x ,float _y){
  x=_x;
  y=_y;
  type=(realFunction(x)>y)?1:-1;
  toPixel();
  }
  Point(){
  x=random(-100,100);
  y=random(-100,100);
  this.type=(realFunction(x)>y)?1:-1;
  toPixel();
  }
  public void toPixel(){
  this.px=map(x,-100,100,0,width-200);
  this.py=map(y,-100,100,height,0);
  this.cords[0]=x;
  this.cords[1]=y;
  this.cords[2]=1;
}
  
  public void show(){
   strokeWeight(2);
    if(type==1){
    stroke(255,255,0);
    }else{
      stroke(0,0,255);
    }
    noFill();
    ellipse(px,py,15,15);
  }
}
public static float realFunction(float x){
  return 0.5f*x-1;
}
class nNetwork{
  private float[] weights=new float[3];
  private float learnRate=0.01f;
  public boolean learnt=false;
  nNetwork(){
    //randomising weights
  weights[0]=random(-1,1);
  weights[1]=random(-1,1);
  weights[2]=random(-1,1);  
  }
  public int guess(Point p){
    int sum =0;
    //calculating output
    for(int i=0;i<weights.length;i++){
     sum+= p.cords[i]*weights[i];
    }
    //calling activation function on the sum 
    return signum(sum);
  }
  //activation functions
   public int signum(float x){
   if(x>0){
   return 1;}
   else{
   return -1;}
   }
   public void train(Point p){
     if(!learnt){
     int guess = guess(p);
     int error = p.type-guess;
     if(error!=0){
       for(int i=0;i<weights.length;i++){
       weights[i]+=p.cords[i]*error*learnRate;
       println(weights);
       learnt=false;
      }
     }  
     }
       
   }
   
   public void show(){
   push();
   for(int i=0;i<weights.length;i++){
    if(weights[i]<0){
        strokeWeight(-1*weights[i]/2);
        stroke(255,0,0);
    }else{
        strokeWeight(weights[i]/2);
       stroke(0,255,0);
    }
    noFill();
    ellipse(width-150+(i*50),50,20,20);
    line(width-150+(i*50),50,width-100,400);
   }
   pop();
    textSize(18);
    fill(255);
    text("OUT",width-110,405);
    noFill();
    ellipse(width-100,400,30,30);
   }
   public float guessY(float x){
     float slope=weights[0]/weights[1];
     float intercept=weights[2]/weights[1];
     return -intercept-(slope*x);
   }
}


  public void settings() { size(1000, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "persceptron" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
